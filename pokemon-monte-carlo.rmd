---
title: "Monte Carlo: 2025 McDonalds Pokemon Cards"
output: 
    html_document:
        theme: flatly
        # toc: true
        # toc_float:
        #     collapsed: false
        #     smooth_scroll: true
        highlight: haddock
---

# Background and Motivation
I was a big fan of the Pokemon games (and I still am!) growing up. While I did start a small Pokemon card
collection, I was never serious about being a collector or trading card game (TCG) player. The cards always 
have pretty and unique art that I enjoy admiring.

On January 21, 2025, McDonalds and Pokemon announced a collaboration, introducing the 
[Pokemon Happy Meal](https://www.pokemon.com/us/pokemon-news/mcdonalds-pokemon-happy-meals-collaboration).
Each Happy Meal came with a TCG four-card booster pack. The collaboration had a set of fifteen cards to collect-- 
seven holofoil and eight standard cards.

Out of boredom, I wondered: "*How many Happy Meals would I have to buy to get all fifteen cards?*" Of
course, I wasn't going to spend who-knows-how-much on Happy Meals-- it'd be a lot more faster (and healthier) 
to run simulations!

# Mathematical Analysis
This is a variation of the [coupon collector's problem](https://en.wikipedia.org/wiki/Coupon_collector%27s_problem)
but with an extra step. Each Happy Meal guarantees one holofoil card and three standard cards with no duplicates.
We can treat this as if the holofoil and standard cards are pulled from separate pools. In other words, the expectated
number of Happy Meals needed to get all holofoil cards and standard cards are independent of each other.

## Expectation of Holofoil Cards
Let $H$ be the number of Happy Meals required to collect all seven holofoil cards. Let $h_i$ be the number
of meals needed to collect the $i$-th new holofoil card after $i-1$ cards have been collected. Note that each 
$h_i$ follows a [geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution)-- that is,
the number of trials for a first success. The total number of meals is $H = h_1 + h_2 + \cdots + h_7$.

Let $h_i$ be the number of meals needed to collect the next new holofoil provided we already have $i$ unique cards.
Let $p_i$ be the probability of pulling a new card we don't have.
$$ \begin{equation*}
    E[h_i] = \frac{1}{p_i} = \frac{7}{7 - i + 1}
\end{equation*}$$

Now, we can calculate the expectation of $H$:
$$ \begin{align*}
    E[H] & = E(h_1 + h_2 + \cdots + h_7) \\
         & = \sum_{i=1}^{7} E(h_i) && \text{linearity of expectation}\\
         & = \sum_{i=1}^{7} \frac{7}{7-i+1} \\
         & = \frac{7}{7} + \frac{7}{7-1} + \cdots + \frac{7}{1} \\
         & = 7 \cdot H_7 && \text{where } H_7 \text{ is the 7th harmonic number} \\
         & \approx 18.15 \text{ Happy Meals}
\end{align*}$$

## Expectation of Standard Cards
Calculating the expectation of the standard cards is similar to the holofoil expectation, but we now have
to account for the fact that three cards are pulled per pack, meaning we have to account for the possibility
of getting 0, 1, 2, or 3 new cards. 

We'll follow the [hypergeometric distribution](https://en.wikipedia.org/wiki/Hypergeometric_distribution).
Given a total of $N$ items, suppose $n$ items are drawn where there are $k$ new items left to collect. The
expectation is given by $E(X) = n \cdot \frac{k}{N}$ 

Let $N = 8$, $n = 3$, and $k= 8 - i$ where $i$ represents the number of unique cards already obtained. Let
$s_i$ be the number of meals needed to collect new card(s) when $i$ unique cards have already been collected.
$$\begin{align*}
    E[s_i \mid i] & = 3 \cdot \frac{8-i}{8}
\end{align*}$$

Let $S$ be the number of Happy Meals required to collect all eight standard cards. It's important to note that
the summation will start from $i = 0$ and go to $i = 7$ as it needs to make sense that we're considering the
range from having $0$ of the unique cards (we have nothing!) to $7$ of the eight cards, meaning we have only
one card left to find.

$$ \begin{align*}
    E[S] & = \sum_{i=0}^{7} \frac{1}{E[s_i \mid i]} \\
         & = \sum_{i=0}^{7} \frac{1}{3 \cdot \frac{8-i}{8}} \\
         & = \sum_{i=0}^{7} \frac{8}{3(8-i)} \\
         & = \frac{8}{3} \sum_{i=0}^{7} \frac{1}{8-i} \\
         & = \frac{8}{3} \sum_{j=1}^{8} \frac{1}{j} && \text{Reindex of $j = 8 - i$} \\
         & = \frac{8}{3} \cdot H_8 && \text{where $H_8$ is the 8th harmonic number} \\
         & \approx 7.25 \text{ Happy Meals} \\
\end{align*} $$

## Putting It Together
With the expectations down (pun very much intended) and foundation laid, we can formalize our original question. We know 
holofoil and standard cards are pulled independently like separate collection processes in parallel. Ultimately, we really 
only "wait" on whichever set takes longer to complete. Formally, let $M$ represent the number of meals needed to collect
all fifteen Pokemon cards.
$$ \begin{align*}
    E[M] & = \text{max}(E[H], E[S]) \\ 
         & = \text{max}(18.15, 7.25) \\ 
         & = 18.15 \text{ Happy Meals}
\end{align*}$$
In short, we're expecting to be bottlenecked by those elusive holofoil cards!

# Monte Carlo Simulation
## Code {.tabset .tabset-fade .tabset-pills}
### `monte_carlo_meals.R`
```{r}
# Run one (1) simulation of buying Happy Meals until all
# fifteen cards are collected.
#
# @return - list of total meals, holofoil meals, and standard
#           meals for one full simulation
buy_meals <- function() {
  # Enumerated holofoil (1-7) and standard sets (1-8)
  holofoils_collected <- rep(FALSE, 7)
  standards_collected <- rep(FALSE, 8)

  # Meal counts
  exp_meals_holofoil <- 0
  exp_meals_standard <- 0

  # Collect holofoils
  while (!all(holofoils_collected)) {
    pulled_cards <- sample(x = (1:7), size = 1)
    holofoils_collected[pulled_cards] <- TRUE
    exp_meals_holofoil <- exp_meals_holofoil + 1
  }

  # Collect standards
  while (!all(standards_collected)) {
    pulled_cards <- sample(x = (1:8), size = 3, replace = FALSE)
    standards_collected[pulled_cards] <- TRUE
    exp_meals_standard <- exp_meals_standard + 1
  }

  # Return list of meal data
  return(list(
    meals_total = max(exp_meals_holofoil, exp_meals_standard),
    meals_holofoil = exp_meals_holofoil,
    meals_standard = exp_meals_standard
  ))
}
```
### `prepare_data.R`
```{r}
# Given data from one Monte Carlo simulation of n iterations,
# prepare it in a data frame to be merged with the main data frame
#
# @param  raw_data - list of experimental number of total meals
# @return simulation_data - a data frame to bind to the main data frame
prepare_data <- function(raw_data) {
  # Constant
  actual_mean <- 18.15

  # Prep data
  meals_total_list <- as.numeric(sapply(raw_data, function(x) x$meals_total))
  meals_holofoil_list <- sapply(raw_data, function(x) x$meals_holofoil)
  meals_standard_list <- sapply(raw_data, function(x) x$meals_standard)

  # Get meal values
  meals_total <- mean(meals_total_list)
  meals_holofoil <- mean(meals_holofoil_list)
  meals_standard <- mean(meals_standard_list)

  # Compute error statistics comparing simulation vs analytical expected value
  n <- length(meals_total_list)
  abs_error <- abs(meals_total - actual_mean)
  std_error <- sd(meals_total_list) / sqrt(n)
  rel_error <- abs((meals_total - actual_mean) / actual_mean) * 100
  variance <- var(meals_total_list)

  # Add experiment for n iterations to experiment data
  simulation_data <- data.frame(Num_Iterations = n,
                                Meals_Holofoil = meals_holofoil,
                                Meals_Standard = meals_standard,
                                Meals_Total = meals_total,
                                Abs_Error = abs_error,
                                Std_Error = std_error,
                                Rel_Error = rel_error,
                                Variance = variance)

  return(simulation_data)
}
```
### `experiment.R` {.active}
```{r}
# Experiment data
experiment_data <- data.frame(Num_Iterations = numeric(),
                              Meals_Holofoil = numeric(),
                              Meals_Standard = numeric(),
                              Meals_Total = numeric(),
                              Abs_Error = numeric(),
                              Std_Error = numeric(),
                              Rel_Error = numeric(),
                              Variance = numeric())

# Experiment variables
num_iterations <- c(10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000)
set.seed(20250121)

# Run experiment
# for (n in num_iterations) {
#   # Run current simulation for n iterations
#   raw_data <- replicate(n, buy_meals(), simplify = FALSE)

#   # Prepare data
#   simulation_data <- prepare_data(raw_data)

#   # Add simulation to experiment data frame
#   experiment_data <- rbind(experiment_data, simulation_data)
# }
```

# Results and Analysis

## Bootstrapping

# Further Considerations and What-ifs
- Donald J. Newman and Lawrence Shepp's [Double Dixie Cup problem](https://faculty.wharton.upenn.edu/wp-content/uploads/2012/04/Double-dixie-cup-problem.pdf)

# Conclusion